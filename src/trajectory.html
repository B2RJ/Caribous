<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trajectory</title>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>

    <style>
        body {
            background-color: #666
        }
    </style>
</head>

<body>
    <H1>Trajectory</H1>
    <div id="trajectory"></div>
    <div id="slider"></div>
    <script>
        /*_____ INITIALISATION & CONFIGURATION _____*/

        const width = 600
        const height = 250
        const zoomValue = 1 << 13 // Zoom dans l'image
        const initialScale = zoomValue
        const initialCenter = [-122.567179, 56.074159]

        // Initialisation de la vue
        const svg = d3
            .select("#trajectory")
            .append("svg")
            .attr("viewBox", [0, 0, width, height])
        const sliderSvg = d3
            .select("#slider")
            .append('svg')
            .attr('width', 700)
            .attr('height', 100)
            .append('g')
            .attr('transform', 'translate(20,20)')
        let slider

        // Définition de la projection (mercator)
        // Passage de coordonnées polaires en coordonnées cartésiennes
        const projection = d3.geoMercator()
            .scale(1 / (2 * Math.PI))
            .translate([0, 0])

        // Setup du nombre de pavé present dans l'image et leur taille
        const tile = d3.tile()
            .extent([[0, 0], [width, height]])
            .tileSize(200)

        // Définition de l'échelle de zoom (min/max), de sa taille et de l'event associé
        const zoom = d3.zoom()
            .scaleExtent([zoomValue, zoomValue])
            .extent([[0, 0], [width, height]])
            .on("zoom", ({ transform }) => zoomed(transform))

        // Création d'un graphique dans le svg
        let image = svg.append("g")
            .attr("pointer-events", "none") // Supprime l'event de clique sur le graphique
            .selectAll("image") // Setup les image mais pas encore créées

        const zoomTransform = d3.zoomIdentity // Appel à l'évenement
            .translate(width / 2, height / 2)
            .scale(-initialScale)
            .translate(...projection(initialCenter))
            .scale(-1)


        /*_____ DATA LOADING & HANDLING _____*/

        let alreadyInitZoomed = false
        let fetchedData = []
        let firstDateRows = []

        const arrowHeadWidth = 12, arrowHeadHeight = arrowHeadWidth
        const arrowPoints = [[2, 2], [10, 6], [2, 10], [6, 6], [2, 2]]

        d3.csv("https://raw.githubusercontent.com/B2RJ/Data-Visualization-Anthropocene/main/data/ourdata/location_means.csv")
            .then(function (data) {
                fetchedData = data

                createSelectList(getHerdNames(data), "herd-names")

                svg
                    .call(zoom) // Setup de l'event de gestion du zoom
                    .call(zoom.transform, zoomTransform) // Placement de la vue aux coordonnées choisies
            })

        function zoomed(transform) {
            // On récupère le numéro des pavés en fonction du context de la view (position et niveau de zoom)
            const tiles = tile(transform)

            // On crée/actualise les images présentes dans le graphique
            // Chaque image représente une portion de carte et chaque image est un pavé
            image = image.data(tiles, d => d).join("image")
                .attr("xlink:href", d => url(...d))
                .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
                .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
                .attr("width", tiles.scale)
                .attr("height", tiles.scale)

            projection
                .scale(transform.k / (2 * Math.PI))
                .translate([transform.x, transform.y])

            const herdName = document.getElementById("herd-names").value //get herdname from html list
            const dates = getDatesByHerdName(fetchedData, herdName)
            updateSlider(dates, alreadyInitZoomed)

            data = getUsefulData(fetchedData, herdName, getRangedDates())
            const lines = svg.selectAll("path").data([data])
            const points = svg.selectAll("circle").data(data)

            if (alreadyInitZoomed) { // UPDATES
                lines
                    .attr("d", d3.line()
                        .x(d => projection(d)[0])
                        .y(d => projection(d)[1]))
            } else { // INITIALIZATION
                lines
                    .enter()
                    .append("path")
                    .attr("marker-end", "url(#arrow)")
                    .attr("d", d3.line()
                        .x(d => projection(d)[0])
                        .y(d => projection(d)[1]))
                    .style("stroke", "red")
                    .style("stroke-linecap", "round")

                svg
                    .append("defs")
                    .append("marker")
                    .attr("id", "arrow")
                    .attr("viewBox", [0, 0, arrowHeadWidth, arrowHeadHeight])
                    .attr("refX", arrowHeadWidth / 2)
                    .attr("refY", arrowHeadHeight / 2)
                    .attr("markerWidth", arrowHeadWidth)
                    .attr("markerHeight", arrowHeadHeight)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", d3.line()(arrowPoints))
                    .style("fill", "red")

                alreadyInitZoomed = true
            }
        }

        function updateSlider(dates, alreadyInitZoomed) {
            firstDateRows = getFirstOfEachYear(dates)

            const firstJanuaryDates = firstDateRows.map(row => row[0])
            const minDate = firstJanuaryDates[0]
            const maxDate = firstJanuaryDates[firstJanuaryDates.length - 1]

            if (alreadyInitZoomed) {
                sliderSvg
                    .call(slider
                        .domain([minDate, maxDate])
                        .tickValues(firstJanuaryDates)
                        .marks(firstJanuaryDates)
                        .value([minDate, maxDate])
                    )
            } else {
                slider = d3
                    .sliderBottom()
                    .domain([minDate, maxDate])
                    .width(650)
                    .tickValues(firstJanuaryDates)
                    .marks(firstJanuaryDates)
                    .tickFormat(d3.timeFormat('%Y'))
                    .fill("red")
                    .value([minDate, maxDate])

                sliderSvg
                    .call(slider)
            }
        }


        /*_____ UTILS FUNCTIONS _____*/

        Array.prototype.distinct = function () {
            return this.filter((elem, index, self) => self.indexOf(elem) === index)
        }

        function getHerdNames(data) {
            return data.map(elem => elem.study_site).distinct()
        }

        function getDatesByHerdName(data, herdName) {
            return getOneHerd(data, herdName).map(elem => new Date(elem.date)).distinct()
        }

        function getOneHerd(data, herdName) {
            return data.filter(elem => elem.study_site === herdName)
        }

        function getYears(data) {
            return data.map(elem => elem.getFullYear()).distinct()
        }

        function getFirstOfEachYear(data) {
            return getYears(data).map(year => [new Date(year, 0, 1), data.find(elem => elem.getFullYear() === year)])
        }

        function getRangedDates() {
            return firstDateRows
                .filter(row => slider.value().find(value => value.getTime() === row[0].getTime()))
                .map(row => row[1])
        }

        function getRangedCoords(data, dateRange) {
            return dateRange.map(date => {
                const row = data.find(row => new Date(row.date).getTime() === date.getTime())
                return [parseFloat(row.longitude), parseFloat(row.latitude)]
            })
        }

        function getUsefulData(data, herdName, dateRange) {
            return getRangedCoords(getOneHerd(data, herdName), dateRange)
        }

        function url(x, y, z) {
            return `https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoicGF3YXJvIiwiYSI6ImNramI5NDIyMDdqMGYydnBkeGVrcGNydDUifQ.k7aT1uH2iIZEAnUC38-QJw`
        }

        function createSelectList(data, listName) {
            let selectList = document.createElement("select")
            selectList.id = listName
            document.body.appendChild(selectList)

            data.forEach(elem => {
                let option = document.createElement("option")
                option.value = elem
                option.text = elem
                selectList.appendChild(option)
            })
        }
    </script>
</body>

</html>