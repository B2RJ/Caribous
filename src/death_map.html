<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Death map</title>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>

    <style>
        body {
            background-color: #666
        }
    </style>
</head>

<body>
    <H1>Death map</H1>
    <div id="death"></div>
    <script>
        /*_______________ INITIAL CONFIGURATION _______________*/


        /*----- Graphical global variables -----*/

        const width = 600
        const height = 250
        const zoomValue = 1 << 14 // Zoom dans l'image
        const initialScale = zoomValue
        const initialCenter = [-122.567179, 55.5]


        /*----- Graphical global components -----*/

        const svg = d3.select("#death")
            .append("svg")
            .attr("viewBox", [0, 0, width, height])
        // Création d'un graphique dans le svg
        let image = svg.append("g")
            .attr("pointer-events", "none") // Supprime l'event de clique sur le graphique
            .selectAll("image") // Setup les image mais pas encore créées


        /*----- D3JS Setup (params, events, etc.) -----*/

        // Setup de la projection (mercator, coordonnées polaires --> coordonnées cartésiennes)
        const projection = d3.geoMercator()
            .scale(1 / (2 * Math.PI))
            .translate([0, 0])

        // Setup du nombre de pavé present dans l'image et leur taille
        const tile = d3.tile()
            .extent([[0, 0], [width, height]])
            .tileSize(200)

        // Définition de l'échelle de zoom (min/max), de sa taille et de l'event associé
        const zoom = d3.zoom()
            .scaleExtent([zoomValue, zoomValue])
            .extent([[0, 0], [width, height]])
            .on("zoom", ({ transform }) => zoomed(transform))

        const zoomTransform = d3.zoomIdentity // Appel à l'évenement
            .translate(width / 2, height / 2)
            .scale(-initialScale)
            .translate(...projection(initialCenter))
            .scale(-1)



        /*_______________ DATA LOADING & HANDLING _______________*/


        /*----- Global variables -----*/

        let alreadyInitZoomed = false
        let clustersMeans = []
        let clustersCoords = []

        const csvUrl = "https://raw.githubusercontent.com/B2RJ/Data-Visualization-Anthropocene/main/data/ourdata/death_reasons.csv"


        /*----- Main process -----*/

        // Load plain csv data from repo
        d3.csv(csvUrl).then(data => {
            clustersCoords = getClusterCoords(data)
            clustersMeans = clustersCoords.map(c => [getMeanCoords(c), c.length])

            svg
                .call(zoom) // Setup de l'event de gestion du zoom
                .on("dblclick.zoom", null)
                .on("mousedown.zoom", null)
                .on("touchstart.zoom", null)
                .on("touchmove.zoom", null)
                .on("touchend.zoom", null)
                .call(zoom.transform, zoomTransform) // Placement de la vue aux coordonnées choisies
        })

        // Initialize or update the map when zooming/moving on map
        function zoomed(transform) {
            console.log("zoomed!")
            // On récupère le numéro des pavés en fonction du context de la view (position et niveau de zoom)
            const tiles = tile(transform)

            // On crée/actualise les images présentes dans le graphique
            // Chaque image représente une portion de carte et chaque image est un pavé
            image = image.data(tiles, d => d).join("image")
                .attr("xlink:href", d => url(...d))
                .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
                .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
                .attr("width", tiles.scale)
                .attr("height", tiles.scale)

            projection
                .scale(transform.k / (2 * Math.PI))
                .translate([transform.x, transform.y])

            const clustersData = []
            for(let i = 0; i < clustersMeans.length; i++) {
                clustersData.push({
                    means: svg.selectAll(".means_"+i).data([clustersMeans[i]]),
                    coords: svg.selectAll(".coords_"+i).data(clustersCoords[i])
                })
            }

            if (alreadyInitZoomed) { // UPDATES
                // TODO: update circles 

            } else { // INITIALIZATION
                // TODO: create circles
                for(let i = 0; i < clustersData.length; i++) {
                    let cd = clustersData[i]
                    cd.coords.enter().append("circle")
                        .attr("class", "coords_"+i)
                        .attr("r", 1)
                        .attr("cx", d => projection(d)[0])
                        .attr("cy", d => projection(d)[1])
                        .style("fill", "None")

                    cd.means.enter().append("circle")
                        .attr("class", "means_"+i)
                        .attr("r", d => 4 + 2*Math.log2(d[1]))
                        .attr("cx", d => projection(d[0])[0])
                        .attr("cy", d => projection(d[0])[1])
                        .style("stroke", "rgba(255,0,0,0.4)")
                        .style("fill", "rgba(255,0,0,0.1)")
                        .on("mouseover", (event, d) => svg.selectAll(".coords_"+i).style("fill", "blue"))
                        .on("mouseleave", (event, d) => svg.selectAll(".coords_"+i).style("fill", "None"))
                }
                alreadyInitZoomed = true
            }
        }



        /*_______________ UTILS FUNCTIONS _______________*/
        function getMeanCoords(coords) {
            const longs = coords.map(c => c[0]);
            const lats = coords.map(c => c[1]);
            return [(Math.min (...longs) + Math.max (...longs)) / 2, (Math.min (...lats) + Math.max (...lats)) / 2]
        }

        function getClusters(data) {
            const dict = {};
            data.forEach(d => {
                if (!dict.hasOwnProperty(d.cluster)) dict[d.cluster] = []
                dict[d.cluster].push(d)
            });
            return Object.values(dict);
        }

        function getCoords(cluster) {
            return cluster.map(d => [d.deploy_off_longitude, d.deploy_off_latitude])
        }

        function getClusterCoords(data) {
            return getClusters(data).map(c => getCoords(c))
        }

        function url(x, y, z) {
            return `https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoicGF3YXJvIiwiYSI6ImNramI5NDIyMDdqMGYydnBkeGVrcGNydDUifQ.k7aT1uH2iIZEAnUC38-QJw`
        }
    </script>
</body>

</html>
